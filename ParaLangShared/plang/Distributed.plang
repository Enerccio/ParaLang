using System;
using System.NetworkException;
using Collections;
using Math;
using IO;

module Distributed {


    ###
    Sorts anything that has get method with index argument, set method with index and object and size method with no arguments in place distributed.
    ###
	defn distributed_sort(gettable){
		return __distributed_sort(gettable, 0, gettable.size());
	}
    
    class __DistributedSortHelper {
        var source;
        var start, end;
    }

    defn __distributed_sort(source, start, end){
    
        var n = System.free_nodes();
		if (n < 2){
			Collections.__merge_sort(source, Collections.__preload_list(new List(), source.size()), start, end);
            return source;
        }
        
        if (end - start < 65){
            Collections.__merge_sort(source, Collections.__preload_list(new List(), source.size()), start, end);
            return source;
        }
            
        var pd = new __DistributedSortHelper();
        pd.source = source;
        pd.start = Collections.integer_array(2);
        pd.end = Collections.integer_array(2);
        
        var mid = (start + end) / 2;
        pd.start.set(0, start);
        pd.end.set(0, mid);
        pd.start.set(1, mid);
        pd.end.set(1, end);
        
        try {
            var result = (dist (2, pd) {
                var start = passed_arg.start.get(run_id);
                var end = passed_arg.end.get(run_id);
                
                return __distributed_sort(passed_arg.source, start, end);
            });
            
            
            Collections.copy(result.get(0), source, start, mid);
            Collections.copy(result.get(1), source, mid, end);
        } catch (NetworkException e){
            Collections.__merge_sort(source, Collections.__preload_list(new List(), source.size()), start, end);
            return source;
        }
        
        return source;
    }
    
    class __DistributedMapHelper {
        var source;
        var functor;
        var start, end;
    }
    
    ###
    Applies map distributely
    ###
    defn distributed_map(collection, n1functor){
        return __distributed_map(collection, n1functor, 0, collection.size());
    }
    
    defn __distributed_map(source, functor, start, end){
        var result = Collections.__preload_list(new List(), source.size()); 
        
        var n = System.free_nodes();
		if (n < 2){
			return Collections.__map(source, result, functor, start, end);
        }
        
        var ratio = (end - start) / n;
        
        if (ratio < 64){
            return Collections.__map(source, result, functor, start, end);
        }
        
        var helper = new __DistributedMapHelper();
        helper.source = source;
        helper.functor = functor;
        helper.start = Collections.integer_array(n);
        helper.end = Collections.integer_array(n);
        
        for (var i=0; i<n; i++){
            helper.start.set(i, i*ratio);
            helper.end.set(i, Math.min(i*ratio+ratio, source.size()));
        }
        
        var computed;
        try {
            computed = (dist (n, helper) {
                var start = passed_arg.start.get(run_id);
                var end = passed_arg.end.get(run_id);
                return __distributed_map(passed_arg.source, passed_arg.functor, start, end);
            });
        } catch (NetworkException e){
            computed = e.get_partial_results();
        }
        
        IO.out.println(source.size());
        for (var i=0; i<computed.size(); i++){
            var partial_result = computed.get(i);
            if (partial_result == NoValue){
                Collections.__map(source, result, functor, helper.start.get(i), helper.end.get(i));
            } else {
                Collections.copy_offset(partial_result, result, helper.start.get(i), helper.end.get(i), 0);
            }
        }
        
        return result;
    }
};