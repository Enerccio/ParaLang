import java.util.HashSet as __JHashSet;
import java.util.ArrayList;
import java.util.HashMap;
import cz.upol.vanusanik.paralang.runtime.wrappers.CollectionsUtils;

###
 Collections is a module containing easy to use collections, such as List, HashSet or Map.
 
 Also provides wrapper to java Interator via Iterator class.
###
module Collections {

    ###
        Wraps java.lang.Iterator<> pointer.
        
        Provides iterator interface.
    ###
    class Iterator {
        
        var __iter;
        
        ### 
            Creates new iterator out of java.lang.Iterator pointer. 
        ###
        defn init(iterator){
            __iter = iterator;
        }
    
        ### 
            Returns next element from iterator.
            *ret any value
        ###
        defn next(){
            return __iter->next();
        }
        
        ###
            Returns whether this iterator has value or not.
            *ret boolean
        ###
        defn has_next(){
            return __iter->hasNext();
        }
        
        ###
            Removes this element from this iterator (optional operation).
            *ret value removed
        ###
        defn remove(){
            return __iter->remove();
        }
    
        defn __str(){
            return __iter;
        }
        
        ###
            Returns whether underline pointer will be transient.
            *ret boolean
        ###
        defn will_be_transient_pointer(){
            return __iter.will_be_transient_pointer();
        }
        
        ###
            Returns whether underline pointer is transient.
            *ret boolean
        ###
        defn is_transient_pointer(){
            return __iter.is_transient_pointer();
        }
    }
    
    ###
        HashSet is container that may contain only one copy of any object. You can query the objects via iterator or via contains method.
    ###
	class HashSet {
		var __wrappedSet = __JHashSet->__JHashSet();
		
        ###
            Adds this object into this set.
        ###
		defn insert(o){
			return __wrappedSet->add(o);
		}
		
        ###
            Nonmodifiable version of insert method. Clones this set and returns new copy with added element.
            *ret HashSet
        ###
		defn push(o){
			var set = new HashSet();
			set.__wrappedSet->addAll(__wrappedSet);
            set.__wrappedSet->add(o);
			return set;
		}
		
        ###
            Returns whether object is in the set.
            *ret boolean
        ###
		defn contains(o){
			return __wrappedSet->contains(o);
		}
		
        ###
            Removes object from the set.
        ###
		defn remove(o){
			return __wrappedSet->remove(o);
		}
        
        ###
            Nonmutable version of remove. Removes object from the copy of this set and returns it.
            *ret HashSet
        ###
		defn purge(o){
			var set = new HashSet();
			set.__wrappedSet->addAll(__wrappedSet);
            set.__wrappedSet->remove(o);
			return set;
		}
		
        ###
            Clears this set.
        ###
		defn clear(){
			__wrappedSet->clear();
		}
		
        ###
            Returns number of elements in this set.
            *ret integer
        ###
		defn size(){
			return __wrappedSet->size();
		}
        
        ###
            Returns iterator to this set
            *ret Iterator
        ###
        defn iterator(){
            return new Iterator(__wrappedSet->iterator());
        }
		
		defn __str(){
			return "Set=" + __wrappedSet;
		}
	}
	
    ###
        List of items. Items are ordered in order of adding to the list.
        
        Search operations are O(n) while access operations are O(1).
    ###
	class List {
		var __wrappedList = ArrayList->ArrayList();
		
        ###
            Adds object into this list.
        ###
		defn add(o){
			return __wrappedList->add(o);
		}
		
        ###
            Nonmutable version of add. Clones this list and then adds object into it and returns new list.
            *ret List
        ###
		defn append(o){
			var list = new List();
            list.__wrappedList->addAll(__wrappedList);
            list.__wrappedList->add(o);
            return list;
		}
		
        ###
            Inserts object at index index.
        ###
		defn insert(index, o){
            if (index < 0 || index >= size())
                throw new BaseException("Index value incorrect, expected <0, " + size() + "), got: " + index);
			return __wrappedList->add(index, o);
		}
		
        ###
            Nonmutable version of insert. Inserts object at index index in clone of this list which is returned.
            *ret List
        ###
		defn append_at(o, index){
            if (index < 0 || index >= size())
                throw new BaseException("Index value incorrect, expected <0, " + size() + "), got: " + index);
			var list = new List();
            list.__wrappedList->addAll(__wrappedList);
            list.__wrappedList->add(index, o);
            return list;
		}
		
        ###
            Removes object o from this list.
        ###
		defn remove(o){
			return __wrappedList->remove(o);
		}
		
        ###
            Removes element at index index and returns it.
            *ret any value
        ###
		defn remove_at(index){
            if (index < 0 || index >= size())
                throw new BaseException("Index value incorrect, expected <0, " + size() + "), got: " + index);
			return CollectionsUtils->removeAt(__wrappedList, index);
		}
        
        ###
            Swaps the object at index index with object o.
        ###
        defn set_at(index, o){
            if (index < 0 || index >= size())
                throw new BaseException("Index value incorrect, expected <0, " + size() + "), got: " + index);
            return __wrappedList->set(index, o);
        }
		
        ###
            Returns object at index index.
        ###
		defn get(index){
            if (index < 0 || index >= size())
                throw new BaseException("Index value incorrect, expected <0, " + size() + "), got: " + index);
            return __wrappedList->get(index);
		}
		
        ###
            Returns index of object o in this List.
        ###
		defn find(o){
			return __wrappedList->indexOf(o);
		}
		
        ###
            Clears this list.
        ###
		defn clear(){
			__wrappedList->clear();
		}
		
        ###
            Returns number of elements in this list.
            *ret integer
        ###
		defn size(){
			return __wrappedList->size();
		}
        
        ###
            Returns iterator to this list.
        ###
        defn iterator(){
            return new Iterator(__wrappedList->iterator());
        }
	
		defn __str(){
			return __wrappedList;
		}
	}

    ###
        Dictionary implementation. Handles key->value association.
        
        Implements it via java.lang.HashMap, so operations are O(1).
    ###
    class Map {
    
        var __wrappedMap = HashMap->HashMap(32);
        
        ###
            Adds association between key and value in this map. Returns previous association, if any.
            *ret any value
        ###
        defn put(key, value){
            return __wrappedMap->put(key, value);
        }
        
        ###
            Nonmutable version of put. Returns new map with that association.
            *ret Map
        ###
        defn push(key, value){
            var m = new Map();
            var it = keys().iterator();
            while (it.has_next()){
                var key = it.next();
                m.__wrappedMap->put(key, get(key));
            }
            m.__wrappedMap->put(key, value);
            return m;
        }
        
        ###
            Returns association with this key, if any.
            *ref any value
        ###
        defn get(key){
            return __wrappedMap->get(key);
        }
        
        ###
            Returns whether key has association in this map.
            *ret boolean
        ###
        defn contains(key){
            return __wrappedMap->containsKey(key);
        }
        
        ###
            Returns whether this value is contained in this map as value.
            *ret boolean
        ###
        defn contains_value(value){
            return __wrappedMap->containsValue(value);
        }
        
        ###
            Removes key from this map. Returns associated value, if any.
            *ret any value
        ###
        defn remove(key){
            return __wrappedMap->remove(key);
        }
        
        ###
            Returns all keys in this map as HashSet.
            *ret HashSet
        ###
        defn keys(){
            var set = new HashSet();
            set.wrappedSet->addAll(__wrappedMap->keySet());
            return set;
        }
        
        ###
            Returns all values in this map as List.
            *ret List
        ###
        defn values(){
            var list = new List();
            list.wrappedList->addAll(__wrappedMap->values());
            return list;
        }
        
        ###
            Returns number of associations in this map.
            *ret integer
        ###
        defn size(){
            return __wrappedMap->size();
        }
        
        ###
            Clears this map.
        ###
        defn clear(){
            __wrappedMap->clear();
        }
        
        defn __str(){
            return __wrappedMap;
        }
    
    }
};