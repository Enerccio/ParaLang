import java.util.HashSet as __JHashSet;
import java.util.ArrayList;
import java.util.HashMap;
import cz.upol.vanusanik.paralang.runtime.wrappers.CollectionsUtils;
import cz.upol.vanusanik.paralang.runtime.wrappers.BooleanArray;
import cz.upol.vanusanik.paralang.runtime.wrappers.IntArray;
import cz.upol.vanusanik.paralang.runtime.wrappers.FloatArray;
import cz.upol.vanusanik.paralang.runtime.wrappers.StringArray;
import cz.upol.vanusanik.paralang.runtime.wrappers.ArrayArray;

using System.BaseException;
using Utils.ArrayIndexOutOfBoundsException;
using Utils.IllegalArgumentException;

###
 Collections is a module containing easy to use collections, such as List, HashSet or Map.
 
 Also provides wrapper to java Interator via Iterator class.
###
module Collections {

    ###
        Collection interface.
    ###
    class Collection {
        
        ###
            Returns value at index ix
        ###
        defn get(ix){
        
        }
        
        ###
            Returns size of the collection
        ###
        defn size(){
            return 0;
        }
    
    }

    ###
        Wraps java.lang.Iterator<> pointer.
        
        Provides iterator interface.
    ###
    class Iterator {
        
        var __iter;
        
        ### 
            Creates new iterator out of java.lang.Iterator pointer. 
        ###
        defn init(iterator){
            __iter = iterator;
        }
    
        ### 
            Returns next element from iterator.
            *ret any value
        ###
        defn next(){
            return __iter->next();
        }
        
        ###
            Returns whether this iterator has value or not.
            *ret boolean
        ###
        defn has_next(){
            return __iter->hasNext();
        }
        
        ###
            Removes this element from this iterator (optional operation).
            *ret value removed
        ###
        defn remove(){
            return __iter->remove();
        }
    
        defn _str(){
            return __iter;
        }
        
        ###
            Returns whether underline pointer will be transient.
            *ret boolean
        ###
        defn will_be_transient_pointer(){
            return __iter.will_be_transient_pointer();
        }
        
        ###
            Returns whether underline pointer is transient.
            *ret boolean
        ###
        defn is_transient_pointer(){
            return __iter.is_transient_pointer();
        }
    }
    
    ###
        HashSet is container that may contain only one copy of any object. You can query the objects via iterator or via contains method.
    ###
	class HashSet {
		var __wrappedSet = __JHashSet->__JHashSet();
		
        ###
            Adds this object into this set.
        ###
		defn insert(o){
			return __wrappedSet->add(o);
		}
		
        ###
            Nonmodifiable version of insert method. Clones this set and returns new copy with added element.
            *ret HashSet
        ###
		defn push(o){
			var set = new HashSet();
			set.__wrappedSet->addAll(__wrappedSet);
            set.__wrappedSet->add(o);
			return set;
		}
		
        ###
            Returns whether object is in the set.
            *ret boolean
        ###
		defn contains(o){
			return __wrappedSet->contains(o);
		}
		
        ###
            Removes object from the set.
        ###
		defn remove(o){
			return __wrappedSet->remove(o);
		}
        
        ###
            Nonmutable version of remove. Removes object from the copy of this set and returns it.
            *ret HashSet
        ###
		defn purge(o){
			var set = new HashSet();
			set.__wrappedSet->addAll(__wrappedSet);
            set.__wrappedSet->remove(o);
			return set;
		}
		
        ###
            Clears this set.
        ###
		defn clear(){
			__wrappedSet->clear();
		}
		
        ###
            Returns number of elements in this set.
            *ret integer
        ###
		defn size(){
			return __wrappedSet->size();
		}
        
        ###
            Returns iterator to this set
            *ret Iterator
        ###
        defn iterator(){
            return new Iterator(__wrappedSet->iterator());
        }
		
		defn _str(){
			return "Set=" + __wrappedSet;
		}
	}
	
    ###
        List of items. Items are ordered in order of adding to the list.
        
        Search operations are O(n) while access operations are O(1).
    ###
	class List > Collection {
		var __wrappedList = ArrayList->ArrayList();
		
        ###
            Adds object into this list.
        ###
		defn add(o){
			return __wrappedList->add(o);
		}
		
        ###
            Nonmutable version of add. Clones this list and then adds object into it and returns new list.
            *ret List
        ###
		defn append(o){
			var list = new List();
            list.__wrappedList->addAll(__wrappedList);
            list.__wrappedList->add(o);
            return list;
		}
		
        ###
            Inserts object at index index.
        ###
		defn insert(index, o){
            if (index < 0 || index >= size())
                throw new BaseException("Index value incorrect, expected <0, " + size() + "), got: " + index);
			return __wrappedList->add(index, o);
		}
		
        ###
            Nonmutable version of insert. Inserts object at index index in clone of this list which is returned.
            *ret List
        ###
		defn append_at(o, index){
            if (index < 0 || index >= size())
                throw new BaseException("Index value incorrect, expected <0, " + size() + "), got: " + index);
			var list = new List();
            list.__wrappedList->addAll(__wrappedList);
            list.__wrappedList->add(index, o);
            return list;
		}
		
        ###
            Removes object o from this list.
        ###
		defn remove(o){
			return __wrappedList->remove(o);
		}
		
        ###
            Removes element at index index and returns it.
            *ret any value
        ###
		defn remove_at(index){
            if (index < 0 || index >= size())
                throw new BaseException("Index value incorrect, expected <0, " + size() + "), got: " + index);
			return CollectionsUtils->removeAt(__wrappedList, index);
		}
        
        ###
            Swaps the object at index index with object o.
        ###
        defn set(index, o){
            if (index < 0 || index >= size())
                throw new BaseException("Index value incorrect, expected <0, " + size() + "), got: " + index);
            return __wrappedList->set(index, o);
        }
		
        ###
            Returns object at index index.
        ###
		defn get(index){
            if (index < 0 || index >= size())
                throw new BaseException("Index value incorrect, expected <0, " + size() + "), got: " + index);
            return __wrappedList->get(index);
		}
		
        ###
            Returns index of object o in this List.
        ###
		defn find(o){
			return __wrappedList->indexOf(o);
		}
		
        ###
            Clears this list.
        ###
		defn clear(){
			__wrappedList->clear();
		}
		
        ###
            Returns number of elements in this list.
            *ret integer
        ###
		defn size(){
			return __wrappedList->size();
		}
        
        ###
            Returns iterator to this list.
        ###
        defn iterator(){
            return new Iterator(__wrappedList->iterator());
        }
	
		defn _str(){
			return __wrappedList;
		}
	}

    ###
        Dictionary implementation. Handles key->value association.
        
        Implements it via java.lang.HashMap, so operations are O(1).
    ###
    class Map {
    
        var __wrappedMap = HashMap->HashMap(32);
        
        ###
            Adds association between key and value in this map. Returns previous association, if any.
            *ret any value
        ###
        defn put(key, value){
            return __wrappedMap->put(key, value);
        }
        
        ###
            Nonmutable version of put. Returns new map with that association.
            *ret Map
        ###
        defn push(key, value){
            var m = new Map();
            var it = keys().iterator();
            while (it.has_next()){
                var key = it.next();
                m.__wrappedMap->put(key, get(key));
            }
            m.__wrappedMap->put(key, value);
            return m;
        }
        
        ###
            Returns association with this key, if any.
            *ref any value
        ###
        defn get(key){
            return __wrappedMap->get(key);
        }
        
        ###
            Returns whether key has association in this map.
            *ret boolean
        ###
        defn contains(key){
            return __wrappedMap->containsKey(key);
        }
        
        ###
            Returns whether this value is contained in this map as value.
            *ret boolean
        ###
        defn contains_value(value){
            return __wrappedMap->containsValue(value);
        }
        
        ###
            Removes key from this map. Returns associated value, if any.
            *ret any value
        ###
        defn remove(key){
            return __wrappedMap->remove(key);
        }
        
        ###
            Returns all keys in this map as HashSet.
            *ret HashSet
        ###
        defn keys(){
            var set = new HashSet();
            set.wrappedSet->addAll(__wrappedMap->keySet());
            return set;
        }
        
        ###
            Returns all values in this map as List.
            *ret List
        ###
        defn values(){
            var list = new List();
            list.wrappedList->addAll(__wrappedMap->values());
            return list;
        }
        
        ###
            Returns number of associations in this map.
            *ret integer
        ###
        defn size(){
            return __wrappedMap->size();
        }
        
        ###
            Clears this map.
        ###
        defn clear(){
            __wrappedMap->clear();
        }
        
        defn _str(){
            return __wrappedMap;
        }
    
    }
    
    ###
    Fixed size array, used to get and set elements. Used to fast access and modification.
    This class is abstract and should not be used. Use functions above to instantiate arrays.
    ###
    class Array > Collection{
    	
    	var _array;
    	var _type_exception;
    	var _length;
    	var _atype;
    	
    	defn init(len){
    		inst._length = len;
    	}
    	
    	###
    	Returns object at index index, or NoValue if there is no object
    	*ret underline object or NoValue
    	###
    	defn get(index){
    		if (index < 0 || index >= _length)
    			throw new ArrayIndexOutOfBoundsException();
    		try {
    			return _array->getUnderlineObject(index);
    		} catch (BaseException e){
    			throw new IllegalArgumentException(_type_exception);
    		}
    	}
    	
    	###
    	Sets the object at index in this array.
    	###
    	defn set(index, object){
    		if (index < 0 || index >= _length)
    			throw new ArrayIndexOutOfBoundsException();
    		try {
    			_array->setUnderlineObject(index, object);
    		} catch (BaseException e){
    			throw new IllegalArgumentException(_type_exception);
    		}
    	}
    	
    	###
    	Returns length of this array
    	###
    	defn size(){
    		return _length;
    	}
    	
    	###
    	Returns type of this array. Types can be "boolean", "int", "float", "string" or "array"; 
    	*ret string
    	###
    	defn get_type(){
    		return _atype;
    	}
    	
    	defn _eq(other){
    		if (other instanceof Array){
    			if (other.size() != size())
    				return false;
    			for (var i=0; i<size(); i++)
    				if (get(i) != other.get(i))
    					return false;
    			return true;
    		}
    		return false;
    	}
    	
    	defn __neq(other){
    		return !_eq(other);
    	}
        
        defn _str(){
            return _array._str();
        }
    }
    
    ###
    Constructs boolean array which will convert all arguments passed in as a boolean
    *ret Array
    ### 
    defn boolean_array(n){
    	return __boolean_array(BooleanArray->BooleanArray(n));
    }
    
    defn __boolean_array(n, internal_array){
    	var array = new Array(n);
    	array._array = internal_array;
    	array._atype = "boolean";
    	return array;
    }
    
    ###
    Constructs integer array which will only allow int/Integer to be passed in
    *ret Array
    ### 
    defn integer_array(n){
    	return __integer_array(n, IntArray->IntArray(n));
    }
    
    defn __integer_array(n, internal_array){
    	var array = new Array(n);
    	array._array = internal_array;
    	array._type_exception = "Incorrect type of argument passed, must be int or Integer";
    	array._atype = "int";
    	return array;
    }
    
    ###
    Constructs float array which will only allow float/Float to be passed in
    *ret Array
    ### 
    defn float_array(n){
    	return __float_array(n, FloatArray->FloatArray(n));
    }
    
    defn __float_array(n, internal_array){
    	var array = new Array(n);
    	array._array = internal_array;
    	array._type_exception = "Incorrect type of argument passed, must be float or Float";
    	array._atype = "float";
    	return array;
    }
    
    ###
    Constructs string array which will only allow string to be passed in
    *ret Array
    ### 
    defn string_array(n){
    	return _string_array(n, StringArray->StringArray(n));
    }
    
    defn __string_array(n, internal_array){
    	var array = new Array(n);
    	array._array = internal_array;
    	array._type_exception = "Incorrect type of argument passed, must be String";
    	array._atype = "string";
    	return array;
    }
    
    class __ArrayArray > Array {
    
    	defn get(index){
    		var array = parent.get(index);
    		var type = array._str();
    		if (type.starts_with("Boolean")){
    			return __boolean_array(array->get_length(), array);
    		}
    		if (type.starts_with("Int")){
    			return __integer_array(array->get_length(), array);
    		}
    		if (type.starts_with("Float")){
    			return __float_array(array->get_length(), array);
    		}
    		if (type.starts_with("String")){
    			return __string_array(array->get_length(), array);
    		}
    		if (type.starts_with("Array")){
    			return __array_array(array->get_length(), array);
    		}
    	}
    	
    	
    	defn set(index, object){
    		if (!(object instanceof Array)){
    		}
    			throw new IllegalArgumentException(__type_exception);
    		parent.set(index, object._array);
    	}
    }
    
    ###
    Constructs array of arrays which will only allow Array to be passed in
    *ret Array
    ### 
    defn array_array(n){
    	return __array_array(n, ArrayArray->ArrayArray(n));
    }
    
    defn __array_array(n, internal_array){
    	var array = new __ArrayArray(n);
    	array._array = internal_array;
    	array._type_exception = "Incorrect type of argument passed, must be Array";
    	array._atype = "array";
    	return array;
    }
    
    // More functions
    
    ###
    Sorts anything that has get method with index argument, set method with index and object and size method with no arguments in place.
    ###
    defn simple_sort(gettable){
    	__merge_sort(gettable, __preload_list(new List(), gettable.size()), 0, gettable.size());
    }
    
    defn __preload_list(list, n){
        for (var i=0; i<n; i++)
            list.add(NoValue);
        return list;
    }
    
    defn __merge_sort(source, result, start, end){
    	if (end - start < 2)
    		return;
    		
    	var mid = (start + end) / 2;
    	__merge_sort(source, result, start, mid);
    	__merge_sort(source, result, mid, end);
    	__merge_sort_merge(source, result, start, mid, end);
        __merge_sort_copy(result, source, start, end);
    }
    
    defn __merge_sort_merge(source, result, start, mid, end){
    	var i0 = start;
    	var i1 = mid;
    	
    	for (var j=start; j<end; j++){
    		if (i0 < mid && (i1 >= end || source.get(i0) <= source.get(i1))){
    			result.set(j, source.get(i0));
    			++i0;
    		} else {
    			result.set(j, source.get(i1));
    			++i1;
    		}
    	}
    }
    
    defn __merge_sort_copy(result, source, start, end){
        for (var k=start; k<end; k++)
            source.set(k, result.get(k));
    }
    
    ###
    Maps the values of the provided collection with n1 functor
    ###
    defn map(collection, n1functor){
        return __map(collection, __preload_list(new List(), collection.size()), n1functor, 0, collection.size());
    }
    
    defn __map(source, result, functor, start, end){
        for (var i=start; i<end; i++)
            result.set(i, functor(source.get(i)));
        return result;
    }
    
    ###
        Reduces elements of collection into single value using n2functor
    ###
    defn reduce(collection, n2functor){
        var init = collection.get(0);
        return __reduce(collection, init, n2functor, 1, collection.size());
    }
    
    defn __reduce(source, result, functor, start, end){
        for (var i=start; i<end; i++)
            result = functor(source.get(i), result);
        return result;
    }
};