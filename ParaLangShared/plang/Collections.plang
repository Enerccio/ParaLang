import cz.upol.vanusanik.paralang.runtime.wrappers.CollectionsUtils;
import cz.upol.vanusanik.paralang.runtime.wrappers.BooleanArray;
import cz.upol.vanusanik.paralang.runtime.wrappers.IntArray;
import cz.upol.vanusanik.paralang.runtime.wrappers.FloatArray;
import cz.upol.vanusanik.paralang.runtime.wrappers.StringArray;
import cz.upol.vanusanik.paralang.runtime.wrappers.ArrayArray;

using System.BaseException;
using Utils.ArrayIndexOutOfBoundsException;
using Utils.IllegalArgumentException;

using IO;

###
 Collections is a module containing easy to use collections, such as List, Set, Map or Array.
 
 Also contains additional functions related to the collections.
###
module Collections {

    ###
        Collection interface.
    ###
    class Collection {
        
        ###
            Returns value at index ix
        ###
        defn get(ix){
        
        }
        
        ###
            Returns size of the collection
        ###
        defn size(){
            return 0;
        }
    
    }
    
    ###
    Fixed size array, used to get and set elements. Used to fast access and modification. This class is abstract and should not be used. Use functions above to instantiate arrays.
    
    This Array is different from system type array, which allows any elements to be set into it. Array, however, is used to store primitives that do not require separate de-serialization and thus is faster to use.
    ###
    class Array > Collection{
    	
    	var _array;
    	var _type_exception;
    	var _length;
    	var _atype;
    	
    	defn init(len){
    		inst._length = len;
    	}
    	
    	###
    	Returns object at index index, or NoValue if there is no object
    	*ret underline object or NoValue
    	###
    	defn get(index){
    		if (index < 0 || index >= _length)
    			throw new ArrayIndexOutOfBoundsException();
    		try {
    			return _array->getUnderlineObject(index);
    		} catch (BaseException e){
    			throw new IllegalArgumentException(_type_exception);
    		}
    	}
    	
    	###
    	Sets the object at index in this array.
    	###
    	defn set(index, object){
    		if (index < 0 || index >= _length)
    			throw new ArrayIndexOutOfBoundsException();
    		try {
    			_array->setUnderlineObject(index, object);
    		} catch (BaseException e){
    			throw new IllegalArgumentException(_type_exception);
    		}
    	}
    	
    	###
    	Returns length of this array
    	###
    	defn size(){
    		return _length;
    	}
    	
    	###
    	Returns type of this array. Types can be "boolean", "int", "float", "string" or "array"; 
    	*ret string
    	###
    	defn get_type(){
    		return _atype;
    	}
    	
    	defn _eq(other){
    		if (other instanceof Array){
    			if (other.size() != size())
    				return false;
    			for (var i=0; i<size(); i++)
    				if (get(i) != other.get(i))
    					return false;
    			return true;
    		}
    		return false;
    	}
    	
    	defn __neq(other){
    		return !_eq(other);
    	}
        
        defn _str(){
            return _array._str();
        }
    }
    
    ###
    Constructs boolean array which will convert all arguments passed in as a boolean
    *ret Array
    ### 
    defn boolean_array(n){
    	return __boolean_array(BooleanArray->BooleanArray(n));
    }
    
    defn __boolean_array(n, internal_array){
    	var array = new Array(n);
    	array._array = internal_array;
    	array._atype = "boolean";
    	return array;
    }
    
    ###
    Constructs integer array which will only allow int/Integer to be passed in
    *ret Array
    ### 
    defn integer_array(n){
    	return __integer_array(n, IntArray->IntArray(n));
    }
    
    defn __integer_array(n, internal_array){
    	var array = new Array(n);
    	array._array = internal_array;
    	array._type_exception = "Incorrect type of argument passed, must be int or Integer";
    	array._atype = "int";
    	return array;
    }
    
    ###
    Constructs float array which will only allow float/Float to be passed in
    *ret Array
    ### 
    defn float_array(n){
    	return __float_array(n, FloatArray->FloatArray(n));
    }
    
    defn __float_array(n, internal_array){
    	var array = new Array(n);
    	array._array = internal_array;
    	array._type_exception = "Incorrect type of argument passed, must be float or Float";
    	array._atype = "float";
    	return array;
    }
    
    ###
    Constructs string array which will only allow string to be passed in
    *ret Array
    ### 
    defn string_array(n){
    	return _string_array(n, StringArray->StringArray(n));
    }
    
    defn __string_array(n, internal_array){
    	var array = new Array(n);
    	array._array = internal_array;
    	array._type_exception = "Incorrect type of argument passed, must be String";
    	array._atype = "string";
    	return array;
    }
    
    class __ArrayArray > Array {
    
    	defn get(index){
    		var array = super.get(index);
    		var type = array._str();
    		if (type.starts_with("Boolean")){
    			return __boolean_array(array->get_length(), array);
    		}
    		if (type.starts_with("Int")){
    			return __integer_array(array->get_length(), array);
    		}
    		if (type.starts_with("Float")){
    			return __float_array(array->get_length(), array);
    		}
    		if (type.starts_with("String")){
    			return __string_array(array->get_length(), array);
    		}
    		if (type.starts_with("Array")){
    			return __array_array(array->get_length(), array);
    		}
    	}
    	
    	
    	defn set(index, object){
    		if (!(object instanceof Array)){
                throw new IllegalArgumentException(__type_exception);
    		}
    		super.set(index, object._array);
    	}
    }
    
    ###
    Constructs array of arrays which will only allow Array to be passed in
    *ret Array
    ### 
    defn array_array(n){
    	return __array_array(n, ArrayArray->ArrayArray(n));
    }
    
    defn __array_array(n, internal_array){
    	var array = new __ArrayArray(n);
    	array._array = internal_array;
    	array._type_exception = "Incorrect type of argument passed, must be Array";
    	array._atype = "array";
    	return array;
    }
    
    // More functions
    
    ###
    Sorts anything that has get method with index argument, set method with index and object and size method with no arguments in place.
    ###
    defn simple_sort(gettable){
    	__merge_sort(gettable, new [gettable.size()], 0, gettable.size());
    }
    
    defn __merge_sort(source, result, start, end){
    	if (end - start < 2)
    		return;
    		
    	var mid = (start + end) / 2;
    	__merge_sort(source, result, start, mid);
    	__merge_sort(source, result, mid, end);
    	__merge_sort_merge(source, result, start, mid, end);
        copy(result, source, start, end);
    }
    
    defn __merge_sort_merge(source, result, start, mid, end){
    	var i0 = start;
    	var i1 = mid;
    	
    	for (var j=start; j<end; j++){
    		if (i0 < mid && (i1 >= end || source.get(i0) <= source.get(i1))){
    			result.set(j, source.get(i0));
    			++i0;
    		} else {
    			result.set(j, source.get(i1));
    			++i1;
    		}
    	}
    }
    
    ###
    Copies data from collection from into object to with set(ix, obj) method from start to end
    ###
    defn copy(from, to, start, end){
        copy_offset(from, to, start, end, 0);
    }
    
    ###
    Same as copy, but offsets the index in to by k
    ###
    defn copy_offset(from, to, start, end, offset){
        for (var k=start; k<end; k++)
                to.set(k+offset, from.get(k));
    }
    
    ###
    Maps the values of the provided collection with n1 functor
    ###
    defn map(collection, n1functor){
        return __map(collection, new [collection.size()], n1functor, 0, collection.size());
    }
    
    defn __map(source, result, functor, start, end){
        for (var i=start; i<end; i++)
            result.set(i, functor(source.get(i)));
        return result;
    }
    
    ###
        Reduces elements of collection into single value using n2functor
    ###
    defn reduce(collection, n2functor){
        var init = collection.get(0);
        return __reduce(collection, init, n2functor, 1, collection.size());
    }
    
    defn __reduce(source, result, functor, start, end){
        for (var i=start; i<end; i++)
            result = functor(source.get(i), result);
        return result;
    }
};