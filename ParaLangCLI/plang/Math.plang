using Collections.List;
using Collections.Map;
using IO;

import cz.upol.vanusanik.paralang.runtime.wrappers.Matrix as __MatrixData;

module Math {

    class MathException > BaseException {
        defn init(message){
            parent.init(message);
        }
    }
    
    class Matrix {
    
        var matrix, n, m;
        
        defn init(n, m){
            inst.n = n;
            inst.m = m;
            matrix = __MatrixData->__MatrixData(n, m);
            
        }   
        
        defn get(i, j){
            return matrix->get(i, j);
        }
        
        defn set(i, j, v){
            matrix->set(i, j, v);
        }
    
        defn __str(){
            return "Matrix <" + m + ", " + n + "> " + __pretty_print_matrix();
        }
        
        defn __pretty_print_matrix(){
            var pp = "[";
            for (var i=0; i<n; i++){
                pp += "[";
                for (var j=0; j<m; j++)
                    pp += get(i, j) + (j == m-1 ? "" : " ");
                pp += "]";
            }
            return pp + "]";
        }
        
        defn __mul(other){
            if (other instanceof Matrix){
                return mul_matrix(other);
            } else {
                return mul_scalar(other);
            }
        }
        
        defn mul_scalar(scalar){
            var nm = new Matrix(n, m);
            for (var i=0; i<n; i++)
                    for (var j=0; j<m; j++){
                        nm.set(i, j, get(i, j) * scalar);
                    }
            return nm;
        }
        
        defn mul_matrix(b){
            if (n != b.m)
                throw new MathException("Incompatible matrices");
            
            var nm = new Matrix(n, n);
            for (var row=0; row<n; row++){
                for (var col=0; col<n; col++){
                    var sum = 0;
                
                    for (var i=0; i<m; i++){
                        sum += get(row, i) * b.get(i, col);
                    }
                    
                    nm.set(row, col, sum);
                }
            }
            
            return nm;
        }
        
    }
    
    class __MatrixMulHelper {
        var matrix;
        var task_map = new Map();
        
        defn set_task(rid, colb, rowa){
            task_map.put(rid, new __MatrixMulHelperTask(colb, rowa));
        }
        
        defn get_task(rid){
            return task_map.get(rid);
        }
    }
    
    class __MatrixMulHelperTask {
        var colb, rowa;
        defn init(cb, ra){
            colb = cb;
            rowa = ra;
        }
    }

    class SquareMatrix > Matrix {
        
        defn init(n){
            parent.init(n, n);
        }
    
    }
    
    defn random_matrix(i, j, r, maxv){
        var m = new Matrix(i, j);
        for (i=0; i<m.n; i++)
            for (j=0; j<m.m; j++)
                m.set(i, j, r.get_int(maxv));
        return m;
    }
    
    defn abs(a){
        return a >= 0 ? a : -a;
    }
    
    defn max(a, b){
        return a >= b ? a : b;
    }
    
    defn min(a, b){
        return a <= b? a : b;
    }
    
    defn sqr(a){
        return a * a;
    }
    
    defn sqrt(a){
        if (!(a instanceof number)) 
            throw new MathException("Argument must be a number!");
              
        if (a instanceof integer) {
            return new Integer(a).sqrt().__val;
        } else {
            return new Float(a).sqrt().__val;
        }
    }
};