import java.util.HashSet as __JHashSet;
import java.util.ArrayList;
import java.util.HashMap;
import cz.upol.vanusanik.paralang.runtime.wrappers.CollectionsUtils;

module Collections {

    class Iterator {
    
        var iter;
        
        defn init(iterator){
            iter = iterator;
        }
    
        defn next(){
            return iter->next();
        }
        
        defn has_next(){
            return iter->hasNext();
        }
        
        defn remove(){
            return iter->remove();
        }
    
        defn __str(){
            return iter;
        }
        
        defn will_be_transient_pointer(){
            return iter.will_be_transient_pointer();
        }
        
        defn is_transient_pointer(){
            return iter.is_transient_pointer();
        }
    }

	class HashSet {
		var wrappedSet = __JHashSet->__JHashSet();
		
		defn insert(o){
			return wrappedSet->add(o);
		}
		
		defn push(o){
			var set = new HashSet();
			set.wrappedSet->addAll(wrappedSet);
            set.wrappedSet->add(o);
			return set;
		}
		
		defn contains(o){
			return wrappedSet->contains(o);
		}
		
		defn remove(o){
			return wrappedSet->remove(o);
		}
		
		defn clear(){
			wrappedSet->clear();
		}
		
		defn size(){
			return wrappedSet->size();
		}
        
        defn iterator(){
            return new Iterator(wrappedSet->iterator());
        }
		
		defn __str(){
			return "Set=" + wrappedSet;
		}
	}
	
	class List {
		var wrappedList = ArrayList->ArrayList();
		
		defn add(o){
			return wrappedList->add(o);
		}
		
		defn append(o){
			var list = new List();
            list.wrappedList->addAll(wrappedList);
            list.wrappedList->add(o);
            return list;
		}
		
		defn insert(index, o){
			return wrappedList->add(index, o);
		}
		
		defn appendAt(o, index){
			var list = new List();
            list.wrappedList->addAll(wrappedList);
            list.wrappedList->add(index, o);
            return list;
		}
		
		defn remove(o){
			return wrappedList->remove(o);
		}
		
		defn removeAt(o){
			return CollectionsUtils->removeAt(wrappedList, o);
		}
        
        defn setAt(index, o){
            return wrappedList->set(index, o);
        }
		
		defn get(index){
			return wrappedList->get(index);
		}
		
		defn find(o){
			return wrappedList->indexOf(o);
		}
		
		defn clear(){
			wrappedList->clear();
		}
		
		defn size(){
			return wrappedList->size();
		}
        
        defn iterator(){
            return new Iterator(wrappedList->iterator());
        }
	
		defn __str(){
			return wrappedList;
		}
	}

    class Map {
    
        var wrappedMap = HashMap->HashMap(32);
        
        defn put(key, value){
            return wrappedMap->put(key, value);
        }
        
        defn push(key, value){
            var m = new Map();
            var it = keys().iterator();
            while (it.has_next()){
                var key = it.next();
                m.wrappedMap->put(key, get(key));
            }
            m.wrappedMap->put(key, value);
            return m;
        }
        
        defn get(key){
            return wrappedMap->get(key);
        }
        
        defn contains(key){
            return wrappedMap->containsKey(key);
        }
        
        defn contains_value(value){
            return wrappedMap->containsValue(value);
        }
        
        defn remove(key){
            return wrappedMap->remove(key);
        }
        
        defn keys(){
            var set = new HashSet();
            set.wrappedSet->addAll(wrappedMap->keySet());
            return set;
        }
        
        defn values(){
            var list = new List();
            list.wrappedList->addAll(wrappedMap->values());
            return list;
        }
        
        defn size(){
            return wrappedMap->size();
        }
        
        defn clear(){
            wrappedMap->clear();
        }
        
        defn __str(){
            return wrappedMap;
        }
    
    }
};